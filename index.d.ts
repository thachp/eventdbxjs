/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class DbxClient {
  constructor(options?: ClientOptions | undefined | null)
  /** Establish a TCP connection to the EventDBX control socket. */
  connect(): Promise<void>
  /** Close the underlying socket, if connected. */
  disconnect(): Promise<void>
  /** Returns `true` if a socket connection is currently held. */
  isConnected(): Promise<boolean>
  /** Returns the configured endpoint (host/port). */
  get endpoint(): ClientEndpoint
  /** List aggregates, optionally restricting to a specific aggregate type. */
  list(aggregateType?: string | undefined | null, options?: PageOptions | undefined | null): Promise<Array<any>>
  /** Fetch a single aggregate snapshot. */
  get(aggregateType: string, aggregateId: string): Promise<any | null>
  /** Select a subset of fields from an aggregate snapshot. */
  select(aggregateType: string, aggregateId: string, fields: Array<string>): Promise<any | null>
  /** List events for an aggregate. */
  events(aggregateType: string, aggregateId: string, options?: PageOptions | undefined | null): Promise<Array<any>>
  /** Append a new event with an arbitrary JSON payload. */
  apply(aggregateType: string, aggregateId: string, eventType: string, options?: AppendOptions | undefined | null): Promise<any>
  /** Create an aggregate and emit its initial event. */
  create(aggregateType: string, aggregateId: string, eventType: string, options?: CreateAggregateOptions | undefined | null): Promise<any>
  /** Archive an aggregate. */
  archive(aggregateType: string, aggregateId: string, options?: SetArchiveOptions | undefined | null): Promise<any>
  /** Restore an archived aggregate. */
  restore(aggregateType: string, aggregateId: string, options?: SetArchiveOptions | undefined | null): Promise<any>
  /** Apply a JSON Patch to the aggregate. Returns the updated snapshot. */
  patch(aggregateType: string, aggregateId: string, eventType: string, operations: Array<any>, options?: PatchOptions | undefined | null): Promise<any>
}

export interface AggregateSortInput {
  field: string
  descending?: boolean
}

export interface AppendOptions {
  payload?: any
  metadata?: any
  note?: string
  token?: string
}

export interface ClientEndpoint {
  ip: string
  port: number
}

export interface ClientOptions {
  ip?: string
  port?: number
  token?: string
  verbose?: boolean
}

export interface CreateAggregateOptions {
  token?: string
  payload?: any
  metadata?: any
  note?: string
}

export declare function createClient(options?: ClientOptions | undefined | null): DbxClient

export interface PageOptions {
  take?: number
  skip?: number
  includeArchived?: boolean
  archivedOnly?: boolean
  token?: string
  filter?: string
  sort?: Array<AggregateSortInput>
}

export interface PatchOptions {
  metadata?: any
  note?: string
  token?: string
}

export interface SetArchiveOptions {
  token?: string
  comment?: string
}
